{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome Page","text":"<p>Welcome to the full documentation of the <code>pose_python</code> repo.</p>"},{"location":"#api-documentation","title":"API Documentation","text":"<ul> <li><code>Pose</code> Class</li> <li><code>RE</code> Class</li> <li><code>TE</code> Class</li> <li><code>Transform</code> Class</li> <li><code>TransformSet</code> Class</li> </ul>"},{"location":"#theory-documentation","title":"Theory Documentation","text":"<ul> <li>Comparing Poses</li> <li>Transformations</li> </ul>"},{"location":"installing_deps/","title":"Installing Dependencies","text":""},{"location":"installing_deps/#python-version-virtual-environment","title":"Python Version &amp; Virtual Environment","text":"<p>This project is being developed on Python 3.10.5.</p> <p>You can learn how to create a virtual environment with the correct python version here.</p>"},{"location":"installing_deps/#dependency-installation","title":"Dependency Installation","text":"<p>All of the dependencies for this project are listed in the <code>requirements.txt</code> file.</p> <p>To install all of the required dependencies you can run the following command in a UNIX terminal:</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"API/er/","title":"ER Class","text":""},{"location":"API/er/#description","title":"Description","text":"<p>This page covers the Euclidean Rotation (<code>ER</code>) class. This class is meant to represent rotations in the 2D and 3D euclidean space. One can use this class to apply a rotation to a 3D or 2D vector. This class is also capable of handling a rotation in its different forms (quaternion, matrix, euler angles, etc.).</p>"},{"location":"API/er/#class-methods","title":"Class Methods","text":""},{"location":"API/er/#erinit","title":"ER.init","text":"<p><code>__init__(self, name: str = '', dim: int = 3) -&gt; None</code></p> <p>The <code>__init__</code> method is called when a new instance of the <code>ER</code> class is created. It initializes all of the variables in the class and sets them to their default values.</p> <p>By default, the <code>self.__rotation</code> member value is set to an identity value.</p> <p>Parameters</p> <ul> <li><code>name</code> (<code>str</code>): Set the name of the object (default: '')</li> <li><code>dim</code> (<code>int</code>): Set the dimension of the vector (default: <code>3</code>)</li> </ul>"},{"location":"API/er/#eridentity","title":"ER.identity","text":"<p><code>identity(self) -&gt; None</code></p> <p>The <code>identity</code> method sets the <code>self.__rotation</code> member to the equivalent of an identity matrix.</p> Example<pre><code>new_rotation = ER()\nnew_rotation.identity()     # Set new_rotation to identity\n</code></pre>"},{"location":"API/er/#errandom","title":"ER.random","text":"<p><code>random(self) -&gt; None</code></p> <p>The <code>random</code> method sets the <code>self.__rotation</code> member to a random value.</p> Example<pre><code>new_rotation = ER()\nnew_rotation.random()   # Set new_rotation to random value\n</code></pre>"},{"location":"API/er/#erinv","title":"ER.inv","text":"<p><code>inv(self) -&gt; None</code></p> <p>The <code>inv</code> method sets the <code>self.__rotation</code> member to its inverse.</p> Example<pre><code>new_rotation = ER()\nnew_rotation.random()   # Set new_rotation to random value\nnew_rotation.inv()      # Set new_rotation to its inverse\n</code></pre>"},{"location":"API/er/#erfrom_quat","title":"ER.from_quat","text":"<p><code>from_quat(self, quat: np.ndarray|list) -&gt; None</code></p> <p>The <code>from_quat</code> method set the <code>self.__rotation</code> member from the value of the input <code>quat</code>.</p> <p>Note: This method will not work for <code>ER</code> objects that are defined in 2D space.</p> <p>Parameters</p> <ul> <li><code>quat</code> (<code>np.ndarray|list</code>): Input quaternion</li> </ul> Example<pre><code>new_rotation = ER()\nnew_rotation.from_quat([0, 0, 0, 1])\n</code></pre>"},{"location":"API/er/#erfrom_matrix","title":"ER.from_matrix","text":"<p><code>from_matrix(self, matrix: np.ndarray) -&gt; None</code></p> <p>The <code>from_matrix</code> method set the <code>self.__rotation</code> member from the value of the input <code>matrix</code>. The method will first check whether the input matrix dimensions are suitable for the number of dimensions set for the <code>ER</code> object.</p> <p>Parameters</p> <ul> <li><code>matrix</code> (<code>np.ndarray</code>): Input matrix</li> </ul> Example<pre><code>new_rotation = ER(dim=2)\nmatrix = np.array([[1, 2], [2, 1]])\nnew_rotation.from_matrix(matrix)\n</code></pre>"},{"location":"API/er/#erfrom_angle","title":"ER.from_angle","text":"<p><code>from_angle_axis(self, angle_axis: np.ndarray) -&gt; None</code></p> <p>The <code>from_angle_axis</code> method set the <code>self.__rotation</code> member from the value of the input <code>angle_axis</code>.</p> <p>Note: This method will not work for <code>ER</code> objects that are defined in 2D space.</p> <p>Parameters</p> <ul> <li><code>angle_axis</code> (<code>np.ndarray</code>): Input angle-axis vector</li> </ul> Example<pre><code>new_rotation = ER()\nmatrix = np.array([1, 2, 3])\nnew_rotation.from_angle_axis(matrix)\n</code></pre>"},{"location":"API/er/#erfrom_euler","title":"ER.from_euler","text":"<p><code>from_euler(self, sequence: str = None, angles: np.ndarray|list = None, degrees: bool = True) -&gt; None</code></p> <p>The <code>from_euler</code> method set the <code>self.__rotation</code> member from the value(s) of the inputs <code>sequence</code> and <code>angles</code>. The angle will be converted from degrees to radians if <code>degrees</code> is <code>True</code>.</p> <p>Parameters</p> <ul> <li><code>sequence</code> (<code>str</code>): Sequence of euler angles (e.g. <code>xyz</code>, <code>xy</code>, <code>zyx</code>)</li> <li><code>angles</code> (<code>np.ndarray|list</code>): List of euler angles</li> <li><code>degrees</code> (<code>bool</code>): Set to true if input angles are in degrees (default: <code>True</code>)</li> </ul> Example<pre><code>new_rotation = ER()\nnew_rotation.from_euler(sequence='xyz', angles=[30, 20, 10], degrees=True)\n</code></pre>"},{"location":"API/er/#eras_quat","title":"ER.as_quat","text":"<p><code>as_quat(self) -&gt; np.ndarray</code></p> <p>Return the stored <code>self.__rotation</code> member in quaternion form.</p> <p>Returns</p> <ul> <li><code>np.ndarray</code>: Quaternion vector</li> </ul> Example<pre><code>new_rotation = ER()\nnew_rotation.random()           # Set to random value\nprint(new_rotation.as_quat())   # Return rotation in quaternion form\n</code></pre>"},{"location":"API/er/#eras_matrix","title":"ER.as_matrix","text":"<p><code>as_matrix(self) -&gt; np.ndarray</code></p> <p>Return the stored <code>self.__rotation</code> member in matrix form.</p> <p>Returns</p> <ul> <li><code>np.ndarray</code>: Rotation matrix</li> </ul> Example<pre><code>new_rotation = ER()\nnew_rotation.random()           # Set to random value\nprint(new_rotation.as_matrix()) # Return rotation in matrix form\n</code></pre>"},{"location":"API/er/#eras_angle_axis","title":"ER.as_angle_axis","text":"<p><code>as_angle_axis(self) -&gt; np.ndarray</code></p> <p>Return the stored <code>self.__rotation</code> member in angle-axis form.</p> <p>Returns</p> <ul> <li><code>np.ndarray</code>: Angle-axis vector</li> </ul> Example<pre><code>new_rotation = ER()\nnew_rotation.random()               # Set to random value\nprint(new_rotation.as_angle_axis()) # Return rotation in matrix form\n</code></pre>"},{"location":"API/er/#eras_euler","title":"ER.as_euler","text":"<p><code>as_euler(self, sequence: str = None, degrees: bool = True) -&gt; np.ndarray|float</code></p> <p>Return the stored <code>self.__rotation</code> member in euler angles.</p> <p>Parameters</p> <ul> <li><code>sequence</code> (<code>str</code>): Sequence in which the euler angle will be returned</li> <li><code>degrees</code> (<code>bool</code>): Option to return euler angles in degrees or not</li> </ul> <p>Returns</p> <ul> <li><code>np.ndarray|float</code>: Euler angle(s) (if <code>ER</code> is in 2D then only a float will be returned)</li> </ul> 3D Example<pre><code>new_rotation = ER()\nnew_rotation.random()                               # Set to random value\nprint(new_rotation.as_euler('xy', degrees=True))    # Return rotation in matrix form\n</code></pre> 2D Example<pre><code>new_rotation = ER(dim=2)\nnew_rotation.random()                       # Set to random value\nprint(new_rotation.as_euler(degrees=True))  # Return rotation in matrix form\n</code></pre>"},{"location":"API/er/#eryaw","title":"ER.yaw","text":"<p><code>yaw(self, degrees: bool = True) -&gt; float</code></p> <p>Return rotation angle around the z axis.</p> <p>Note: This method will not work for 2D rotations. It is recommended to use <code>as_euler()</code> instead.</p> <p>Parameters</p> <ul> <li><code>degrees</code> (<code>bool</code>): Option to return value in degrees or radians (default: <code>True</code>)</li> </ul> <p>Returns</p> <ul> <li><code>float</code>: Yaw angle (in specified units)</li> </ul> Example<pre><code>new_rotation = ER()\nnew_rotation.random()       # Set to random value\nprint(new_rotation.yaw())   # Return yaw angle of rotation\n</code></pre>"},{"location":"API/er/#erpitch","title":"ER.pitch","text":"<p><code>pitch(self, degrees: bool = True) -&gt; float</code></p> <p>Return rotation angle around the y axis.</p> <p>Note: This method will not work for 2D rotations. It is recommended to use <code>as_euler()</code> instead.</p> <p>Parameters</p> <ul> <li><code>degrees</code> (<code>bool</code>): Option to return value in degrees or radians (default: <code>True</code>)</li> </ul> <p>Returns</p> <ul> <li><code>float</code>: Pitch angle (in specified units)</li> </ul> Example<pre><code>new_rotation = ER()\nnew_rotation.random()       # Set to random value\nprint(new_rotation.pitch()) # Return pitch angle of rotation\n</code></pre>"},{"location":"API/er/#erroll","title":"ER.roll","text":"<p><code>roll(self, degrees: bool = True) -&gt; float</code></p> <p>Return rotation angle around the x axis.</p> <p>Note: This method will not work for 2D rotations. It is recommended to use <code>as_euler()</code> instead.</p> <p>Parameters</p> <ul> <li><code>degrees</code> (<code>bool</code>): Option to return value in degrees or radians (default: <code>True</code>)</li> </ul> <p>Returns</p> <ul> <li><code>float</code>: Roll angle (in specified units)</li> </ul> Example<pre><code>new_rotation = ER()\nnew_rotation.random()       # Set to random value\nprint(new_rotation.roll())  # Return roll angle of rotation\n</code></pre>"},{"location":"API/er/#erapply","title":"ER.apply","text":"<p><code>apply(self, input: np.ndarray|list) -&gt; np.ndarray</code></p> <p>The <code>apply</code> method applies this rotation to <code>input</code> vector.</p> <p>Note: The dimension of the input vector must match the set dimension of the <code>ER</code> object.</p> <p>Parameters</p> <ul> <li><code>input</code> (<code>np.ndarray|list</code>): Input vector to be rotated</li> </ul> <p>Returns</p> <ul> <li><code>np.ndarray</code>: Rotated vector</li> </ul> Example<pre><code>vector = np.array([2, 3, 1])\nnew_rotation = ER()\nnew_rotation.random()       # Set to random value\nrotated_vector = new_rotation.apply(vector)\n</code></pre>"},{"location":"API/et/","title":"ET Class","text":""},{"location":"API/et/#description","title":"Description","text":"<p>This page covers the Euclidean Translation (<code>ET</code>) class. This class is meant to represent positions and translations in the 2D and 3D euclidean space. One can use this class to apply a translation to a 3D or 2D vector.</p>"},{"location":"API/et/#class-methods","title":"Class Methods","text":""},{"location":"API/et/#etinit","title":"ET.init","text":"<p><code>__init__(self, name: str = '', dim: int = 3, vector: np.ndarray|list = None) -&gt; None</code></p> <p>The <code>__init__</code> method is called when a new instance of the <code>ET</code> class is created. It initializes all of the variables in the class and sets them to their default values.</p> <p>By default, the <code>self.__vector</code> member value is set to zero.</p> <p>Parameters</p> <ul> <li><code>name</code> (<code>str</code>): Set the name of the object (default: '')</li> <li><code>dim</code> (<code>int</code>): Set the dimension of the vector (default: <code>3</code>)</li> <li><code>vector</code> (<code>np.ndarray|list</code>): Set value of vector at <code>__init__</code> (default: <code>None</code>)</li> </ul>"},{"location":"API/et/#etrandom","title":"ET.random","text":"<p><code>random(self) -&gt; None</code></p> <p>The <code>random</code> method sets the <code>self.__vector</code> member to a random state.</p> Example<pre><code>new_position = ET()\nnew_position.random()           # Set to random value\n</code></pre>"},{"location":"API/et/#etfrom_vector","title":"ET.from_vector","text":"<p><code>from_vector(self, vector: np.ndarray|list) -&gt; None</code></p> <p>The <code>from_vector</code> method sets the <code>self.__vector</code> to the input vector.</p> <p>The method also checks whether the input dimension matches the class dimension.</p> <p>Parameters</p> <ul> <li><code>vector</code> (<code>np.ndarray|list</code>): Input vector</li> </ul> Example<pre><code>new_position = ET()\nnew_position.from_vector([3, 2, 1]) # Set value from input vector/list\n</code></pre>"},{"location":"API/et/#etzero","title":"ET.zero","text":"<p><code>zero(self) -&gt; None</code></p> <p>The <code>zero</code> method sets the <code>self.__vector</code> to zero.</p> Example<pre><code>new_position = ET()\nnew_position.random()   # Set to random value\nnew_position.zero()     # Set to zero\n</code></pre>"},{"location":"API/et/#etinv","title":"ET.inv","text":"<p><code>inv(self) -&gt; None</code></p> <p>The <code>inv</code> method sets the <code>self.__vector</code> member to its inverse (negative value).</p> Example<pre><code>new_position = ET()\nnew_position.random()   # Set to random value\nnew_position.inv()      # Set to negative value of random values\n</code></pre>"},{"location":"API/et/#etvector","title":"ET.vector","text":"<p><code>vector(self) -&gt; np.ndarray</code></p> <p>Return the value of the <code>self.__vector</code> member.</p> <p>Returns</p> <ul> <li><code>np.ndarray</code>: Value of <code>self.__vector</code> member</li> </ul> Example<pre><code>new_position = ET()\nnew_position.random()   # Set to random value\nnew_position.vector()   # Return position vector\n</code></pre>"},{"location":"API/et/#etx","title":"ET.x","text":"<p><code>x(self) -&gt; float</code></p> <p>Return the first element of the <code>self.__vector</code> member.</p> <p>Returns</p> <ul> <li><code>float</code>: First element of the <code>self.__vector</code> member</li> </ul> Example<pre><code>new_position = ET()\nnew_position.random()   # Set to random value\nnew_position.x()        # Return first element of position vector\n</code></pre>"},{"location":"API/et/#ety","title":"ET.y","text":"<p><code>y(self) -&gt; float</code></p> <p>Return the second element of the <code>self.__vector</code> member.</p> <p>Returns</p> <ul> <li><code>float</code>: Second element of the <code>self.__vector</code> member</li> </ul> Example<pre><code>new_position = ET()\nnew_position.random()   # Set to random value\nnew_position.y()        # Return second element of position vector\n</code></pre>"},{"location":"API/et/#etz","title":"ET.z","text":"<p><code>z(self) -&gt; float</code></p> <p>Return the third element of the <code>self.__vector</code> member.</p> <p>Note: This method will only work for <code>ET</code> classes set to 3 dimensions.</p> <p>Returns</p> <ul> <li><code>float</code>: Third element of the <code>self.__vector</code> member</li> </ul> Example<pre><code>new_position = ET()\nnew_position.random()   # Set to random value\nnew_position.z()        # Return third element of position vector\n</code></pre>"},{"location":"API/pose/","title":"Pose Class","text":""},{"location":"API/pose/#description","title":"Description","text":"<p>This page covers the <code>Pose</code> class. In this documentation, a pose is defined as a description of the position and the orientation of an object, and can exist in 2D or 3D. Hence, the <code>Pose</code> class allows the user to handle a position and orientation in 2D or 3D, by making use of the <code>ET</code> and <code>ER</code> classes set to the respective number of dimensions.</p>"},{"location":"API/pose/#class-methods","title":"Class Methods","text":""},{"location":"API/pose/#poseinit","title":"Pose.init","text":"<p><code>__init__(self, name: str = '', dim: int = 3) -&gt; None</code></p> <p>The <code>__init__</code> method is called when a new instance of the <code>Pose</code> class is created. It initializes all of the variables in the class and sets them to their default values.</p> <p>Parameters</p> <ul> <li><code>name</code> (<code>str</code>): Set the name of the object (default: '')</li> <li><code>dim</code> (<code>int</code>): Set the dimension of the vector (default: 3)</li> </ul>"},{"location":"API/pose/#poserandom","title":"Pose.random","text":"<p><code>random(self) -&gt; None</code></p> <p>Sets the position and orientation to random values.</p> Example<pre><code>new_pose = Pose()\nnew_pose.random()\n</code></pre>"},{"location":"API/pose/#posezero","title":"Pose.zero","text":"<p><code>zero(self) -&gt; None</code></p> <p>Sets the position vector to zero and orientation to identity.</p> Example<pre><code>new_pose = Pose()\nnew_pose.zero()\n</code></pre>"},{"location":"API/pose/#value-extraction","title":"Value Extraction","text":"<p>To extract the raw values of the position and orientation, it is recommended to go through the <code>ER</code> and <code>ET</code> members.</p> Example<pre><code>new_pose = Pose()\nnew_pose.random()\nyaw_angle = new_pose.orientation.yaw()          # Get yaw angle\nposition_vector = new_pose.position.vector()    # Get position vector\n</code></pre> <p>Refer to the documentation of the <code>ER</code> and <code>ET</code> classes to become familiar with their methods.</p>"},{"location":"API/transform/","title":"Transform","text":""},{"location":"API/transform/#description","title":"Description","text":"<p>This page covers the <code>Transform</code> class. This class is meant to represent transformations between frames and poses in 2D or 3D space. One should use this class to apply a transformation to a pose or a 2D/3D vector.</p>"},{"location":"API/transform/#class-methods","title":"Class Methods","text":""},{"location":"API/transform/#transforminit","title":"Transform.init","text":"<p><code>__init__(self, name: str, orig: str = 'origin', dest: str = 'destination', te_dim: int = 3, re_dim: int = 3) -&gt; None</code></p> <p>The <code>__init__</code> method is called when a new instance of the <code>Transform</code> class is created. It initializes all of the variables in the class and sets them to their default values.</p> <p>By default, the <code>self.translation</code> and <code>self.rotation</code> are set to zero and identity.</p> <p>Parameters</p> <ul> <li><code>name</code> (<code>str</code>): Set the name of the object (default: '')</li> <li><code>orig</code> (<code>str</code>): Set the name of the origin frame (default: <code>origin</code>)</li> <li><code>dest</code> (<code>str</code>): Set the name of the destination frame (default: <code>destination</code>)</li> <li><code>te_dim</code> (<code>int</code>): Set the number of dimensions of the translation element (default: <code>3</code>)</li> <li><code>re_dim</code> (<code>int</code>): Set the number of dimensions of the rotation element (default: <code>3</code>)</li> </ul>"},{"location":"API/transform/#transformbetween_poses","title":"Transform.between_poses","text":"<p><code>between_poses(self, pose_1: Pose, pose_2: Pose) -&gt; None</code></p> <p>Compute transform between 2 3D poses. This instance of Transform will be modifed to compute the transform from <code>pose_1</code> to <code>pose_2</code>.</p> <p>Parameters</p> <ul> <li><code>pose_1</code> (<code>Pose</code>): Origin pose</li> <li><code>pose_2</code> (<code>Pose</code>): Destination pose</li> </ul>"},{"location":"API/transform/#transformidentity","title":"Transform.identity","text":"<p><code>identity(self) -&gt; None</code></p> <p>Set the transformation to zero and the rotation to identity.</p>"},{"location":"API/transform/#transforminv","title":"Transform.inv","text":"<p><code>inv(self) -&gt; None</code></p> <p>Set the transformation it's inverse.</p>"},{"location":"API/transform/#transformrandom","title":"Transform.random","text":"<p><code>random(self) -&gt; None</code></p> <p>Set a random transformation.</p>"},{"location":"API/transform/#transformdims","title":"Transform.dims","text":"<p><code>dims(self) -&gt; tuple[int, int]</code></p> <p>Returns the dimensions of the translation and rotation (in that order).</p> <p>Returns</p> <ul> <li><code>tuple[int, int]</code>: Dimension of translation and rotation (in that order)</li> </ul>"},{"location":"API/transform/#transformmatrix","title":"Transform.matrix","text":"<p><code>matrix(self, homogeneous: bool = True) -&gt; np.ndarray</code></p> <p>Return the transformation matrix.</p> <p>Returns</p> <ul> <li><code>np.ndarray</code>: Transformation matrix</li> </ul>"},{"location":"API/transform/#transformapply","title":"Transform.apply","text":"<p><code>apply(self, io: Pose|np.ndarray) -&gt; Pose|np.ndarray</code></p> <p>Apply transformation to <code>io</code>.</p> <p>Parameters</p> <ul> <li><code>io</code> (<code>Pose | np.ndarray</code>): Element to apply transformation to</li> </ul> <p>Returns</p> <ul> <li><code>Pose|np.ndarray</code>: Output pose/vector</li> </ul>"},{"location":"API/transform_set/","title":"Transform Set","text":""},{"location":"API/transform_set/#description","title":"Description","text":"<p>This page covers <code>TransformSet</code> class. This class is meant to represent a group of transforms in 2D or 3D space. One should use this class to apply transformations to a vector or pose.</p>"},{"location":"API/transform_set/#class-methods","title":"Class Methods","text":""},{"location":"API/transform_set/#transformsetadd_frame","title":"TransformSet.add_frame","text":"<p><code>add_frame(self, frame_name: str, frame_data: dict|Pose) -&gt; None</code></p> <p>Add frame to transform set.</p> <p>Parameters</p> <ul> <li><code>frame_name</code> (<code>str</code>): Name of new frame</li> <li><code>frame_data</code> (<code>dict | Pose</code>): Data of frame</li> </ul>"},{"location":"API/transform_set/#transformsetframe_names","title":"TransformSet.frame_names","text":"<p><code>frame_names(self) -&gt; list</code></p> <p>Return list of frame names.</p> <p>Returns</p> <ul> <li><code>list</code>: List of saved frame names</li> </ul>"},{"location":"API/transform_set/#transformsetchange_frame","title":"TransformSet.change_frame","text":"<p><code>change_frame(self, input, from_frame: str, to_frame: str) -&gt; np.ndarray</code></p> <p>Coordinate transformation of a pose (6D vector) from origin frame to target frame.</p> <p>A compund transformation from origin frame (defined in <code>from_frame</code> argument) to the target frame (defined in <code>to_frame</code> argument) is computed and applied to the input pose.</p> <p>Parameters</p> <ul> <li><code>input</code> (<code>np.ndarray</code>): Input pose</li> <li><code>from_frame</code> (<code>str</code>): Name of origin frame</li> <li><code>to_frame</code> (<code>str</code>): Name of target frame</li> </ul> <p>Returns</p> <ul> <li><code>np.ndarray</code>: Transformed pose in target frame</li> </ul>"},{"location":"API/transform_set/#transformsetwrench_change_frame","title":"TransformSet.wrench_change_frame","text":"<p><code>wrench_change_frame(self, wrench: np.ndarray, from_frame: str, to_frame: str) -&gt; np.ndarray</code></p> <p>Method to change frame of wrench vector.</p> <p>Method will perform simple rotation on forces (first three elements), and will rotate the total moments on the origin frame.</p> <p>Parameters</p> <ul> <li><code>wrench</code> (<code>np.ndarray</code>): Input wrench array</li> <li><code>from_frame</code> (<code>str</code>): Name of origin frame</li> <li><code>to_frame</code> (<code>str</code>): Name of target frame</li> </ul> <p>Returns</p> <ul> <li><code>np.ndarray</code>: Transformed wrench array</li> </ul>"},{"location":"API/transform_set/#transformsettransform_matrix","title":"TransformSet.transform_matrix","text":"<p><code>transform_matrix(self, from_frame: str, to_frame: str, homogeneous: bool = True) -&gt; np.ndarray</code></p> <p>Return the transformation matrix to transform poses from origin frame to destination frame.</p> <p>Method will call the <code>__create_compound_transf()</code> method. Note that such a matrix can only be directly used for poses. Other calculations are required for wrench transformations.</p> <p>Parameters</p> <ul> <li><code>from_frame</code> (<code>str</code>): Name of origin frame</li> <li><code>to_frame</code> (<code>str</code>): Name of target frame</li> <li><code>homogeneous</code> (<code>bool</code>): Option if matrix should be homogenous or not (3x4 or 4x4) (default: <code>True</code>)</li> </ul> <p>Returns</p> <ul> <li><code>np.ndarray</code>: Numpy matrix</li> </ul>"},{"location":"API/transform_set/#transformset__create_compound_transf","title":"TransformSet.__create_compound_transf","text":"<p><code>__create_compound_transf(self, from_frame: str, to_frame: str) -&gt; Transform</code></p> <p>Method to create compound transform between two frames.</p> <p>Parameters</p> <ul> <li><code>from_frame</code> (<code>str</code>): Name of origin frame</li> <li><code>to_frame</code> (<code>str</code>): Name of destination frame</li> </ul> <p>Returns</p> <ul> <li><code>Transform</code>: Transform object</li> </ul>"},{"location":"Theory/comparing_poses/","title":"Comparing Poses","text":"<p>Comparing poses might sound like a simple task at first, however in practice it can get quite complicated. The <code>PoseComparison</code> class contains a static method to help solve these problems.</p>"},{"location":"Theory/comparing_poses/#comparing-translations","title":"Comparing Translations","text":"<p>Comparing translations is a simple task as it just involves two 3-dimensional vectors that can be subtracted to determine the difference between them.</p>"},{"location":"Theory/comparing_poses/#comparing-rotations","title":"Comparing Rotations","text":"<p>Comparing rotations involves more thought than rotations. Let us use an example to help guide us through this process. The way we choose to represent this difference is as an angle on a sphere.</p> <p>Say we have two rotations \\(R_1\\) and \\(R_2\\). As with all 3D rotations, there are many ways to describe/represent them:</p> <ul> <li>Euler Angles</li> <li>Quaternion</li> <li>3\\(\\times\\)3 Matrix</li> <li>Rodrigues Vector</li> </ul> <p>A good way to determine the compound rotation between \\(R_1\\) and \\(R_2\\) is to multiply the matrix of one by the inverted matrix of the other:</p> \\[ M_{\\text{compound}} = M_1^{-1} M_2 \\] <p>To determine the angle on the sphere that separate these two rotations, we can take norm of the Rodrigues representation of the compound rotation, as that defines the angle of the compound rotation between the two rotations:</p> \\[ \\text{Value} = \\|\\vec{r}_{\\text{compound}} \\| \\] <p>This value can then be compared with a threshold (close to zero) to determine if \\(R_1\\) and \\(R_2\\) are different or not.</p>"},{"location":"Theory/transformations/","title":"Transformations","text":"<p>Transformations are vital to for almost automation project.</p>"},{"location":"Theory/transformations/#transformations-inverse-transformations","title":"Transformations &amp; Inverse Transformations","text":"<p>The transformations that we handle in this library are composed of rotations and translations. They can be represented as matrix, such as the following:</p> \\[ \\underline{T} = \\begin{bmatrix} \\underline{R} &amp; \\vec{t} \\\\ [0]_{3\\times 1} &amp; 1 \\end{bmatrix} \\] <p>where \\(\\underline{R}\\) is the rotation matrix and \\(\\vec{t}\\) is the translation vector.</p> <p>The inverse transform can be determined by the following operations on the elements of the original transformation:</p> \\[ T^{-1} = \\begin{bmatrix} \\underline{R}^{-1} &amp; -\\underline{R}\\vec{t} \\\\ [0]_{3\\times 1} &amp; 1 \\end{bmatrix} \\]"},{"location":"Theory/transformations/#transforming-vectors","title":"Transforming Vectors","text":"<p>Transforming vectors involves the following operations below (in their order): 1. Apply rotation to vector 2. Add translation vector to rotated vector</p> <p>This can of course be done be multiplying the transformation matrix by the homogeneous variation of the input vector (while other methods exist, this is the most common and easiest to understand).</p>"},{"location":"Theory/transformations/#transforming-poses","title":"Transforming Poses","text":"<p>In this documentation, we define a pose \\(P\\) as an element containing an orientation \\(O\\) and a position \\(E\\).</p> <p>Transforming poses is similar to transforming a vector. If we want to transform a pose \\(P\\) from frame \\(A\\) to frame \\(B\\) we do the following:</p> <ul> <li> <p>Apply the transformation rotation to the orientation of the pose:</p> \\[ O_B = R_{A\\rightarrow B} O_A \\] </li> <li> <p>Add the transformation's translation to the position of the pose:</p> \\[ E_B = E_A + \\vec{t}_{A\\rightarrow B} \\] </li> </ul>"},{"location":"Theory/transformations/#transforming-forces-torques","title":"Transforming Forces &amp; Torques","text":"<p>Transforming the forces and torques (also known as a wrench vector) involves different calculations than for a simple vector. Let us demonstrate the theory with example parameters.</p> <p>Say we have a wrench vector in the frame \\(A\\) (\\(\\vec{W}_A\\)), and we want to transform the force and torque elements to the frame \\(B\\). We know the transformation \\(T_{A\\rightarrow B}\\).</p> <p>To transform the force \\(\\vec{F}_A\\), we just need to apply the rotation to the force vector:</p> \\[ \\vec{F}_B = R_{A\\rightarrow B} \\vec{F}_A \\] <p>To transform the torque \\(\\vec{M}_A\\), we do the following calculation:</p> \\[ \\vec{M}_B = R_{A\\rightarrow B} \\left[ \\left(\\vec{F}_A \\times \\vec{t}_{A\\rightarrow B}\\right) + \\vec{M}_A \\right] \\]"}]}