{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Page Welcome to the full documentation of the pose_python repo. API Documentation Pose Class Rotation2D Class PoseComparison Class Transform Class TransformSet Class Theory Documentation Comparing Poses Transformations","title":"Welcome Page"},{"location":"#welcome-page","text":"Welcome to the full documentation of the pose_python repo.","title":"Welcome Page"},{"location":"#api-documentation","text":"Pose Class Rotation2D Class PoseComparison Class Transform Class TransformSet Class","title":"API Documentation"},{"location":"#theory-documentation","text":"Comparing Poses Transformations","title":"Theory Documentation"},{"location":"installing_deps/","text":"Installing Dependencies Python Version & Virtual Environment This project is being developed on Python 3.10.5. You can learn how to create a virtual environment with the correct python version here . Dependency Installation All of the dependencies for this project are listed in the requirements.txt file. To install all of the required dependencies you can run the following command in a UNIX terminal: pip install -r requirements.txt","title":"Installing Dependencies"},{"location":"installing_deps/#installing-dependencies","text":"","title":"Installing Dependencies"},{"location":"installing_deps/#python-version-virtual-environment","text":"This project is being developed on Python 3.10.5. You can learn how to create a virtual environment with the correct python version here .","title":"Python Version &amp; Virtual Environment"},{"location":"installing_deps/#dependency-installation","text":"All of the dependencies for this project are listed in the requirements.txt file. To install all of the required dependencies you can run the following command in a UNIX terminal: pip install -r requirements.txt","title":"Dependency Installation"},{"location":"API/pose/","text":"Pose Class This page covers the Pose and Pose2D class. For the 3D Pose class, this class is a wrapper around the following: scipy.spatial.transform.Rotation Documentation Link numpy.array Documentation Link The 2D Pose2D class is a wrapper around the following: pose_python.Rotation2D numpy.array Documentation Link The documentation for these classes can be found by clicking on their respective links. Member Variables Name Type Description name str String to hold the name of the pose. This variable must be set when a new instance of the class is created. position numpy.ndarray 3D array meant to to hold the position element of the pose. orientation scipy.spatial.transform.Rotation Rotation element meant to hold the orientation of the pose. Class Methods Name Description __init__ Constructor function: Requires name to be set, will set the position to [0, 0, 0] and the rotation to identity. print Print the elements of the pose to the console (will print the rotation in euler angles). random Set the position and rotation to random (mostly used for testing purposes). Requirements Name Description Code Link Documentation Link numpy The fundamental package for scientific computing with Python https://github.com/numpy/numpy https://numpy.org/doc/ scipy General management of scientific data https://github.com/scipy/scipy https://docs.scipy.org/doc/scipy-1.8.1/","title":"Pose Class"},{"location":"API/pose/#pose-class","text":"This page covers the Pose and Pose2D class. For the 3D Pose class, this class is a wrapper around the following: scipy.spatial.transform.Rotation Documentation Link numpy.array Documentation Link The 2D Pose2D class is a wrapper around the following: pose_python.Rotation2D numpy.array Documentation Link The documentation for these classes can be found by clicking on their respective links.","title":"Pose Class"},{"location":"API/pose/#member-variables","text":"Name Type Description name str String to hold the name of the pose. This variable must be set when a new instance of the class is created. position numpy.ndarray 3D array meant to to hold the position element of the pose. orientation scipy.spatial.transform.Rotation Rotation element meant to hold the orientation of the pose.","title":"Member Variables"},{"location":"API/pose/#class-methods","text":"Name Description __init__ Constructor function: Requires name to be set, will set the position to [0, 0, 0] and the rotation to identity. print Print the elements of the pose to the console (will print the rotation in euler angles). random Set the position and rotation to random (mostly used for testing purposes).","title":"Class Methods"},{"location":"API/pose/#requirements","text":"Name Description Code Link Documentation Link numpy The fundamental package for scientific computing with Python https://github.com/numpy/numpy https://numpy.org/doc/ scipy General management of scientific data https://github.com/scipy/scipy https://docs.scipy.org/doc/scipy-1.8.1/","title":"Requirements"},{"location":"API/pose_comparison/","text":"Pose Comparison Class The PoseComparison class allows us to compare the similarity between poses for their orientation and position. Note This class only contains static functions, therefore the methods of this class need to be called with the class name first. Example: different_pose : bool = PoseComparison . different_pose ( pose_1 , pose_2 ) Class Methods Name Description different_pose Returns True if two poses are different (difference is below a given threshold). calc_difference Calculate the difference between two poses. Requirements Name Description Code Link Documentation Link numpy The fundamental package for scientific computing with Python https://github.com/numpy/numpy https://numpy.org/doc/ scipy General management of scientific data https://github.com/scipy/scipy https://docs.scipy.org/doc/scipy-1.8.1/","title":"Pose Comparison Class"},{"location":"API/pose_comparison/#pose-comparison-class","text":"The PoseComparison class allows us to compare the similarity between poses for their orientation and position. Note This class only contains static functions, therefore the methods of this class need to be called with the class name first. Example: different_pose : bool = PoseComparison . different_pose ( pose_1 , pose_2 )","title":"Pose Comparison Class"},{"location":"API/pose_comparison/#class-methods","text":"Name Description different_pose Returns True if two poses are different (difference is below a given threshold). calc_difference Calculate the difference between two poses.","title":"Class Methods"},{"location":"API/pose_comparison/#requirements","text":"Name Description Code Link Documentation Link numpy The fundamental package for scientific computing with Python https://github.com/numpy/numpy https://numpy.org/doc/ scipy General management of scientific data https://github.com/scipy/scipy https://docs.scipy.org/doc/scipy-1.8.1/","title":"Requirements"},{"location":"API/rotation2d/","text":"Rotation2D Class This class was created to mimic the capabilities of the scipy.spatial.transform.Rotation class for 2D usage. Member Variables Name Type Description angle float Float to hold rotation angle (only a single value is needed in 2D space). Class Methods Name Description __init__ Construction function - Set angle to 0 apply Apply rotation to input_vector inv Create new rotation with inverted angle (thus an inverse rotation) from_euler Set angles using euler angles value from_matrix Set angles using rotation matrix as_euler Return rotation as euler angle (degrees can be chosen as unit, default is radians) as_matrix Return rotation as rotation matrix identity Set rotation angle to 0 random Set rotation angle to random value between 0 and \\(2\\pi\\) align_vectors Set rotation angle to value that aligns two vectors Name Description Code Link Documentation Link numpy The fundamental package for scientific computing with Python https://github.com/numpy/numpy https://numpy.org/doc/","title":"Rotation2D Class"},{"location":"API/rotation2d/#rotation2d-class","text":"This class was created to mimic the capabilities of the scipy.spatial.transform.Rotation class for 2D usage.","title":"Rotation2D Class"},{"location":"API/rotation2d/#member-variables","text":"Name Type Description angle float Float to hold rotation angle (only a single value is needed in 2D space).","title":"Member Variables"},{"location":"API/rotation2d/#class-methods","text":"Name Description __init__ Construction function - Set angle to 0 apply Apply rotation to input_vector inv Create new rotation with inverted angle (thus an inverse rotation) from_euler Set angles using euler angles value from_matrix Set angles using rotation matrix as_euler Return rotation as euler angle (degrees can be chosen as unit, default is radians) as_matrix Return rotation as rotation matrix identity Set rotation angle to 0 random Set rotation angle to random value between 0 and \\(2\\pi\\) align_vectors Set rotation angle to value that aligns two vectors Name Description Code Link Documentation Link numpy The fundamental package for scientific computing with Python https://github.com/numpy/numpy https://numpy.org/doc/","title":"Class Methods"},{"location":"API/transform/","text":"Transform Class The Transform class contains all of the requirements to transform a vector, pose or wrench to another coordinate frame. Member Variables Name Type Description name str Name to give to transform (must be set for every new instance). orig str Name given to origin frame of reference. dest str Name given to destination frame of reference. translation np.ndarray Translation vector assigned to transformation (set to 0 at new instance). rotation scipy.spatial.transform.Rotation Rotation class assigned to transformation (set to identity at new instance). Class Methods Name Description print Print rotation and translation of transformation to console (will print rotation as euler angles in degrees). inv Create new transformation that is the inverse of the current transformation. apply Apply transformation to an input (can be a vector or a pose). matrix Return a transformation matrix of the current transformation (can be homogeneous or not - Default: True ) random Assign random values to the rotation and translation elements of the transformation. Requirements Name Description Code Link Documentation Link numpy The fundamental package for scientific computing with Python https://github.com/numpy/numpy https://numpy.org/doc/ scipy General management of scientific data https://github.com/scipy/scipy https://docs.scipy.org/doc/scipy-1.8.1/","title":"Transform Class"},{"location":"API/transform/#transform-class","text":"The Transform class contains all of the requirements to transform a vector, pose or wrench to another coordinate frame.","title":"Transform Class"},{"location":"API/transform/#member-variables","text":"Name Type Description name str Name to give to transform (must be set for every new instance). orig str Name given to origin frame of reference. dest str Name given to destination frame of reference. translation np.ndarray Translation vector assigned to transformation (set to 0 at new instance). rotation scipy.spatial.transform.Rotation Rotation class assigned to transformation (set to identity at new instance).","title":"Member Variables"},{"location":"API/transform/#class-methods","text":"Name Description print Print rotation and translation of transformation to console (will print rotation as euler angles in degrees). inv Create new transformation that is the inverse of the current transformation. apply Apply transformation to an input (can be a vector or a pose). matrix Return a transformation matrix of the current transformation (can be homogeneous or not - Default: True ) random Assign random values to the rotation and translation elements of the transformation.","title":"Class Methods"},{"location":"API/transform/#requirements","text":"Name Description Code Link Documentation Link numpy The fundamental package for scientific computing with Python https://github.com/numpy/numpy https://numpy.org/doc/ scipy General management of scientific data https://github.com/scipy/scipy https://docs.scipy.org/doc/scipy-1.8.1/","title":"Requirements"},{"location":"API/transform_set/","text":"TransformSet Class The TransformSet class is created to make it easy to define multiple reference frames, and the relations between them, as to make it easy for the developer to transform between two reference frames. Usage The reference frames are defined in a configuration file (toml format). An example can be found below: frames.toml [base] translation = [0.0, 0.0, 0.0] # [m] orientation = [0.0, 0.0, 0.0] orientation_type = 'euler' orientation_units = 'degrees' [acp] translation = [0.0011, 0.0022, -0.1903] # [m] orientation = [-0.1, -0.1, -179.999] orientation_type = 'euler' orientation_units = 'degrees' Requirements for a TransformSet configuration file: One of the reference frames must be marked as a base . The orientation_type must always be present ( orientation_units are only needed for the types of rotation where it makes sense to define them). When initializing a new TransformSet , such a configuration file must be given as an argument. Consistency in the translation units Application in Code The following short script uses the frames.toml file to define two reference frames and transform a vector between them: from pose_python import TransformSet import numpy as np frames = TransformSet ( file = 'frames.toml' ) vector = np . array ([ 1 , 1 , 1 ]) new_vector = frames . change_frame ( input = vector , from_frame = 'base' , to_frame = 'acp' ) The significant advantage here is that we can call the reference frames by name, and can therefore perform complex transformations easily and in a single line. Member Variables Name Type Description frame_data dict Dictionary containing all of the data collected from the toml config file. frame_names list List of all of the frames found in the config file. transformations list List of all transformations extracted from the config file. Class Methods Name Description __init__ Construction function - Will read and parse the data from the config file. Config file path is required as argument. change_frame Apply transformation(s) to an input vector or pose. wrench_change_frame Apply transformation(s) to an input wrench vector ( np.ndarray of size 6). transform_matrix Return transformation matrix of transformation required to pass from one frame to another. __create_compound_transf Combine two transformations: the first going from origin frame back to base frame, and another going from base frame to the destination frame Requirements Name Description Code Link Documentation Link numpy The fundamental package for scientific computing with Python https://github.com/numpy/numpy https://numpy.org/doc/ scipy General management of scientific data https://github.com/scipy/scipy https://docs.scipy.org/doc/scipy-1.8.1/","title":"TransformSet Class"},{"location":"API/transform_set/#transformset-class","text":"The TransformSet class is created to make it easy to define multiple reference frames, and the relations between them, as to make it easy for the developer to transform between two reference frames.","title":"TransformSet Class"},{"location":"API/transform_set/#usage","text":"The reference frames are defined in a configuration file (toml format). An example can be found below: frames.toml [base] translation = [0.0, 0.0, 0.0] # [m] orientation = [0.0, 0.0, 0.0] orientation_type = 'euler' orientation_units = 'degrees' [acp] translation = [0.0011, 0.0022, -0.1903] # [m] orientation = [-0.1, -0.1, -179.999] orientation_type = 'euler' orientation_units = 'degrees' Requirements for a TransformSet configuration file: One of the reference frames must be marked as a base . The orientation_type must always be present ( orientation_units are only needed for the types of rotation where it makes sense to define them). When initializing a new TransformSet , such a configuration file must be given as an argument. Consistency in the translation units","title":"Usage"},{"location":"API/transform_set/#application-in-code","text":"The following short script uses the frames.toml file to define two reference frames and transform a vector between them: from pose_python import TransformSet import numpy as np frames = TransformSet ( file = 'frames.toml' ) vector = np . array ([ 1 , 1 , 1 ]) new_vector = frames . change_frame ( input = vector , from_frame = 'base' , to_frame = 'acp' ) The significant advantage here is that we can call the reference frames by name, and can therefore perform complex transformations easily and in a single line.","title":"Application in Code"},{"location":"API/transform_set/#member-variables","text":"Name Type Description frame_data dict Dictionary containing all of the data collected from the toml config file. frame_names list List of all of the frames found in the config file. transformations list List of all transformations extracted from the config file.","title":"Member Variables"},{"location":"API/transform_set/#class-methods","text":"Name Description __init__ Construction function - Will read and parse the data from the config file. Config file path is required as argument. change_frame Apply transformation(s) to an input vector or pose. wrench_change_frame Apply transformation(s) to an input wrench vector ( np.ndarray of size 6). transform_matrix Return transformation matrix of transformation required to pass from one frame to another. __create_compound_transf Combine two transformations: the first going from origin frame back to base frame, and another going from base frame to the destination frame","title":"Class Methods"},{"location":"API/transform_set/#requirements","text":"Name Description Code Link Documentation Link numpy The fundamental package for scientific computing with Python https://github.com/numpy/numpy https://numpy.org/doc/ scipy General management of scientific data https://github.com/scipy/scipy https://docs.scipy.org/doc/scipy-1.8.1/","title":"Requirements"},{"location":"Theory/comparing_poses/","text":"Comparing Poses Comparing poses might sound like a simple task at first, however in practice it can get quite complicated. The PoseComparison class contains a static method to help solve these problems. Comparing Translations Comparing translations is a simple task as it just involves two 3-dimensional vectors that can be subtracted to determine the difference between them. Comparing Rotations Comparing rotations involves more thought than rotations. Let us use an example to help guide us through this process. The way we choose to represent this difference is as an angle on a sphere. Say we have two rotations \\(R_1\\) and \\(R_2\\) . As with all 3D rotations, there are many ways to describe/represent them: Euler Angles Quaternion 3 \\(\\times\\) 3 Matrix Rodrigues Vector A good way to determine the compound rotation between \\(R_1\\) and \\(R_2\\) is to multiply the matrix of one by the inverted matrix of the other: \\[ M_{\\text{compound}} = M_1^{-1} M_2 \\] To determine the angle on the sphere that separate these two rotations, we can take norm of the Rodrigues representation of the compound rotation, as that defines the angle of the compound rotation between the two rotations: \\[ \\text{Value} = \\|\\vec{r}_{\\text{compound}} \\| \\] This value can then be compared with a threshold (close to zero) to determine if \\(R_1\\) and \\(R_2\\) are different or not.","title":"Comparing Poses"},{"location":"Theory/comparing_poses/#comparing-poses","text":"Comparing poses might sound like a simple task at first, however in practice it can get quite complicated. The PoseComparison class contains a static method to help solve these problems.","title":"Comparing Poses"},{"location":"Theory/comparing_poses/#comparing-translations","text":"Comparing translations is a simple task as it just involves two 3-dimensional vectors that can be subtracted to determine the difference between them.","title":"Comparing Translations"},{"location":"Theory/comparing_poses/#comparing-rotations","text":"Comparing rotations involves more thought than rotations. Let us use an example to help guide us through this process. The way we choose to represent this difference is as an angle on a sphere. Say we have two rotations \\(R_1\\) and \\(R_2\\) . As with all 3D rotations, there are many ways to describe/represent them: Euler Angles Quaternion 3 \\(\\times\\) 3 Matrix Rodrigues Vector A good way to determine the compound rotation between \\(R_1\\) and \\(R_2\\) is to multiply the matrix of one by the inverted matrix of the other: \\[ M_{\\text{compound}} = M_1^{-1} M_2 \\] To determine the angle on the sphere that separate these two rotations, we can take norm of the Rodrigues representation of the compound rotation, as that defines the angle of the compound rotation between the two rotations: \\[ \\text{Value} = \\|\\vec{r}_{\\text{compound}} \\| \\] This value can then be compared with a threshold (close to zero) to determine if \\(R_1\\) and \\(R_2\\) are different or not.","title":"Comparing Rotations"},{"location":"Theory/transformations/","text":"Transformations Transformations are vital to for almost automation project. Transformations & Inverse Transformations The transformations that we handle in this library are composed of rotations and translations. They can be represented as matrix, such as the following: \\[ \\underline{T} = \\begin{bmatrix} \\underline{R} & \\vec{t} \\\\ [0]_{3\\times 1} & 1 \\end{bmatrix} \\] where \\(\\underline{R}\\) is the rotation matrix and \\(\\vec{t}\\) is the translation vector. The inverse transform can be determined by the following operations on the elements of the original transformation: \\[ T^{-1} = \\begin{bmatrix} \\underline{R}^{-1} & -\\underline{R}\\vec{t} \\\\ [0]_{3\\times 1} & 1 \\end{bmatrix} \\] Transforming Vectors Transforming vectors involves the following operations below (in their order): 1. Apply rotation to vector 2. Add translation vector to rotated vector This can of course be done be multiplying the transformation matrix by the homogeneous variation of the input vector (while other methods exist, this is the most common and easiest to understand). Transforming Poses In this documentation, we define a pose \\(P\\) as an element containing an orientation \\(O\\) and a position \\(E\\) . Transforming poses is similar to transforming a vector. If we want to transform a pose \\(P\\) from frame \\(A\\) to frame \\(B\\) we do the following: Apply the transformation rotation to the orientation of the pose: \\[ O_B = R_{A\\rightarrow B} O_A \\] Add the transformation's translation to the position of the pose: \\[ E_B = E_A + \\vec{t}_{A\\rightarrow B} \\] Transforming Forces & Torques Transforming the forces and torques (also known as a wrench vector) involves different calculations than for a simple vector. Let us demonstrate the theory with example parameters. Say we have a wrench vector in the frame \\(A\\) ( \\(\\vec{W}_A\\) ), and we want to transform the force and torque elements to the frame \\(B\\) . We know the transformation \\(T_{A\\rightarrow B}\\) . To transform the force \\(\\vec{F}_A\\) , we just need to apply the rotation to the force vector: \\[ \\vec{F}_B = R_{A\\rightarrow B} \\vec{F}_A \\] To transform the torque \\(\\vec{M}_A\\) , we do the following calculation: \\[ \\vec{M}_B = R_{A\\rightarrow B} \\left[ \\left(\\vec{F}_A \\times \\vec{t}_{A\\rightarrow B}\\right) + \\vec{M}_A \\right] \\]","title":"Transformations"},{"location":"Theory/transformations/#transformations","text":"Transformations are vital to for almost automation project.","title":"Transformations"},{"location":"Theory/transformations/#transformations-inverse-transformations","text":"The transformations that we handle in this library are composed of rotations and translations. They can be represented as matrix, such as the following: \\[ \\underline{T} = \\begin{bmatrix} \\underline{R} & \\vec{t} \\\\ [0]_{3\\times 1} & 1 \\end{bmatrix} \\] where \\(\\underline{R}\\) is the rotation matrix and \\(\\vec{t}\\) is the translation vector. The inverse transform can be determined by the following operations on the elements of the original transformation: \\[ T^{-1} = \\begin{bmatrix} \\underline{R}^{-1} & -\\underline{R}\\vec{t} \\\\ [0]_{3\\times 1} & 1 \\end{bmatrix} \\]","title":"Transformations &amp; Inverse Transformations"},{"location":"Theory/transformations/#transforming-vectors","text":"Transforming vectors involves the following operations below (in their order): 1. Apply rotation to vector 2. Add translation vector to rotated vector This can of course be done be multiplying the transformation matrix by the homogeneous variation of the input vector (while other methods exist, this is the most common and easiest to understand).","title":"Transforming Vectors"},{"location":"Theory/transformations/#transforming-poses","text":"In this documentation, we define a pose \\(P\\) as an element containing an orientation \\(O\\) and a position \\(E\\) . Transforming poses is similar to transforming a vector. If we want to transform a pose \\(P\\) from frame \\(A\\) to frame \\(B\\) we do the following: Apply the transformation rotation to the orientation of the pose: \\[ O_B = R_{A\\rightarrow B} O_A \\] Add the transformation's translation to the position of the pose: \\[ E_B = E_A + \\vec{t}_{A\\rightarrow B} \\]","title":"Transforming Poses"},{"location":"Theory/transformations/#transforming-forces-torques","text":"Transforming the forces and torques (also known as a wrench vector) involves different calculations than for a simple vector. Let us demonstrate the theory with example parameters. Say we have a wrench vector in the frame \\(A\\) ( \\(\\vec{W}_A\\) ), and we want to transform the force and torque elements to the frame \\(B\\) . We know the transformation \\(T_{A\\rightarrow B}\\) . To transform the force \\(\\vec{F}_A\\) , we just need to apply the rotation to the force vector: \\[ \\vec{F}_B = R_{A\\rightarrow B} \\vec{F}_A \\] To transform the torque \\(\\vec{M}_A\\) , we do the following calculation: \\[ \\vec{M}_B = R_{A\\rightarrow B} \\left[ \\left(\\vec{F}_A \\times \\vec{t}_{A\\rightarrow B}\\right) + \\vec{M}_A \\right] \\]","title":"Transforming Forces &amp; Torques"}]}